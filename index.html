<!doctype html>
<html lang="en">
	<head>
		<title>Face tracker</title>
		<meta charset="utf-8">
		<style>
			@import url(https://fonts.googleapis.com/css?family=Lato:300italic,700italic,300,700);
			
			body {
				font-family: 'Lato';
				background-color: #f0f0f0;
				margin: 0px auto;
				max-width: 1150px;
			}
			
			#overlay {
				top: 0px;
				left: 0px;
				-o-transform : scaleX(-1);
				-webkit-transform : scaleX(-1);
				transform : scaleX(-1);
				-ms-filter : fliph; /*IE*/
				filter : fliph; /*IE*/

				width : 600px;
				height : 450px;
			}

			#videoel {
				-o-transform : scaleX(-1);
				-webkit-transform : scaleX(-1);
				transform : scaleX(-1);
				-ms-filter : fliph; /*IE*/
				filter : fliph; /*IE*/

				width : 600px;
				height : 450px;
				display: none;
			}
			
			#container {
				position : relative;
				width : 370px;
				/*margin : 0px auto;*/
			}
			
			#content {
				margin-top : 50px;
				margin-left : auto;
				margin-right : auto;
				max-width: 600px;
			}
			

		</style>
	</head>
	<body>
		<script src="./js/utils.js"></script>
		<script src="./js/clmtrackr.js"></script>
		<script src="./models/model_pca_20_svm_emotionDetection.js"></script>
		<script src="./js/emotion_classifier.js"></script>
		<script src="./js/emotionmodel.js"></script>
		<div id="content">
			
			<div id="container">
				<video id="videoel" width="400" height="300" preload="auto" loop>
				</video>
				<canvas id="overlay" width="400" height="300"></canvas>
				<p id="0"></p>
				<p id="1"></p>
				<p id="2"></p>
				<p id="3"></p>
			</div>
			
			<script>
				

	var vid = document.getElementById('videoel');
	var overlay = document.getElementById('overlay');
	var overlayCC = overlay.getContext('2d');

	navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
	window.URL = window.URL || window.webkitURL || window.msURL || window.mozURL;

	// check for camerasupport
	if (navigator.getUserMedia) {
		// set up stream
		
		var videoSelector = {video : true};
		if (window.navigator.appVersion.match(/Chrome\/(.*?) /)) {
			var chromeVersion = parseInt(window.navigator.appVersion.match(/Chrome\/(\d+)\./)[1], 10);
			if (chromeVersion < 20) {
				videoSelector = "video";
			}
		};

		navigator.getUserMedia(videoSelector, function( stream ) {
			if (vid.mozCaptureStream) {
				vid.mozSrcObject = stream;
			} else {
				vid.src = (window.URL && window.URL.createObjectURL(stream)) || stream;
				startVideo()
			}
			vid.play();
		}, function() {
			//insertAltVideo(vid);
			alert("There was some problem trying to fetch video from your webcam. If you have a webcam, please make sure to accept when the browser asks for access to your webcam.");
		});
	} else {
		//insertAltVideo(vid);
		alert("This demo depends on getUserMedia, which your browser does not seem to support. :(");
	}

	/*********** setup of emotion detection *************/

	var ctrack = new clm.tracker({useWebGL : true});
	ctrack.init(pModel);

	function startVideo() {
		// start video
		vid.play();
		// start tracking
		ctrack.start(vid);
		// start loop to draw face
		drawLoop();
	}

	function averagePoints(pointArray){
		//takes in array of 2 element arrays, returns 2 element array [xavg, yavg]

		var averageCoordinates = [0,0]

		pointArray.forEach(function(point){
			for(var i = 0; i < averageCoordinates.length; i++)
				averageCoordinates[i] += point[i]
		})

		return averageCoordinates.map(function(e){
			return e / pointArray.length
		})
	}

	function computeBoundingBox(pointArray){
		//todo - outlier elimination?
		var ret = {
			maxX: pointArray[0][0],
			maxY: pointArray[0][1],
			minX: pointArray[0][0],
			minY: pointArray[0][1]
		}

		for(var i = 1; i < pointArray.length; i++){
			var point = pointArray[i]
			ret.maxX = Math.max(ret.maxX, point[0])
			ret.minX = Math.min(ret.minX, point[0])
			ret.maxY = Math.max(ret.maxY, point[1])
			ret.minY = Math.min(ret.minY, point[1])
		}

		var verticalMarginRatio = 0.10
		var upperVerticalRatio = 0.3//because the model does not include the top of the head

		var horizontalMarginRatio = 0.025

		var verticalRange = ret.maxY - ret.minY
		var horizontalRange = ret.maxX - ret.minX

		var verticalMargin = verticalMarginRatio * verticalRange
		var horizontalMargin = horizontalMarginRatio * horizontalRange

		ret.maxX += horizontalMargin
		ret.minX -= horizontalMargin

		ret.maxY += verticalMargin 
		ret.minY -= verticalMargin + verticalMarginRatio * verticalRange

		ret.width = ret.maxX - ret.minX
		ret.height = ret.maxY - ret.minY

		return ret


	}

	function makeCircle(boundingBox){

		var center = [boundingBox.minX + boundingBox.width / 2, boundingBox.minY + boundingBox.height / 2]
		var radius = Math.pow(boundingBox.height * boundingBox.height + boundingBox.width * boundingBox.width, 1/2) / 2

		return {
			center: center,
			radius: radius
		}
	}

	function drawCircle(context, center, radius){
		context.beginPath()

		context.arc(center[0], center[1], radius, 0, 2 * Math.PI)

		context.fill()
	}

	function makeEmoji(name, src, weights){
		var emoji = {
			name: name,
			src: src,
			weights: weights.slice(0)
		}

		var source = new Image()
		source.src = src

		emoji.source = source

		source.onload = function(){
			emoji.source = source
			globalSource = source
		}

		return emoji

	}

	function drawEmoji(context, center, radius, emojiSource){
		try{
			context.drawImage(emojiSource, center[0] - radius, center[1] - radius, radius * 2, radius * 2)
		} catch(e){
			console.log(e)
			console.log(emojiSource)
		}
	}

	var emojis = []
	var base = 0.05
	var treble = 0.55
	emojis.push(makeEmoji("neutral", "/img/neutral.svg", [base, base, base, base]))
	emojis.push(makeEmoji("angry", "/img/angry.svg", [treble, base, base, base]))
	emojis.push(makeEmoji("sad", "/img/crying.svg", [base, treble, base, base]))
	emojis.push(makeEmoji("surprised", "/img/surprised.svg", [base, base, treble, base]))
	emojis.push(makeEmoji("happy", "/img/smiling.svg", [base, base, base, treble]))

	function calculateDistanceSquared(weightArray, emojiWeightArray){
		var d = 0;

		for(var i = 0; i < weightArray.length; i++)
			d += Math.pow(weightArray[i] - emojiWeightArray[i], 2)

		return d
	}

	function calculateEmoji(weightArray){
		var bestDistanceSquared = calculateDistanceSquared(weightArray, emojis[0].weights)
		var bestEmojiIndex = 0
		for(var i = 1; i < emojis.length; i++){
			var distanceSquared = calculateDistanceSquared(weightArray, emojis[i].weights)
			if(distanceSquared < bestDistanceSquared){
				bestEmojiIndex = i
				bestDistanceSquared = distanceSquared
			}
		}//this doesn't work too well

		return emojis[bestEmojiIndex]

		// var highestWeight = base
		// var emotion = "neutral"

		// for(var i = 0; i < weightObjectArray.length; i++){
		// 	var weightObject = weightObjectArray[i]
		// 	var weight = weightObject.value
		// 	document.getElementById(i+"").innerHTML = weight
		// 	if(weight >= treble && weight > highestWeight){
		// 		highestWeight = weight
		// 		emotion = weightObject.emotion
		// 	}
		// }


		// for(var i = 0; i < emojis.length; i++){
		// 	if(emojis[i].name == emotion)
		// 		return emojis[i]
		// }

		// return null

	}


	function toWeightArray(er){
		var ret = []
		er.forEach(function(e){
			ret.push(e.value)
		})
		return ret
	}

	function drawLoop() {
		requestAnimFrame(drawLoop);
		overlayCC.clearRect(0, 0, 400, 300);
		overlayCC.drawImage(vid, 0, 0, overlay.width, overlay.height);
		//psrElement.innerHTML = "score :" + ctrack.getScore().toFixed(4);
		if (ctrack.getCurrentPosition()) {
			// ctrack.draw(overlay);
			var positions = ctrack.getCurrentPosition()
			
			var boundingBox = computeBoundingBox(positions)

			var circleDetails = makeCircle(boundingBox)

			// drawCircle(overlayCC, circleDetails.center, circleDetails.radius)



			var cp = ctrack.getCurrentParameters();
			
			var er = ec.meanPredict(cp);//tracks the emotion values
			
			//[angry, sad, surprised, happy]
			if (er) {
				var weightArray = toWeightArray(er)
				lastWeightArray = weightArray
				var emoji = calculateEmoji(weightArray)
				drawEmoji(overlayCC, circleDetails.center, circleDetails.radius, emoji.source)
			}

			

			

			// for(var i = 0; i < positions.length; i++){
			// 	var position = positions[i];
			// 	var hueRatio = i / positions.length;
			// 	overlayCC.fillStyle = "hsl(" + (360 * hueRatio) + ", 50%, 50%)"
			// 	overlayCC.fillRect(position[0],position[1],1,1);
			// }
		}

	}

	var ec = new emotionClassifier();
	ec.init(emotionModel);
	var emotionData = ec.getBlank();	

			
				
			</script>
		</div>
	</body>
</html>
